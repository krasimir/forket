"use client";
import ReactDomClient from "react-dom/client";
import React from "react";
import f_11 from "./components/case03/Page.tsx";
import f_10 from "./components/case02/Page.tsx";
import f_9 from "./components/case01/Page.tsx";
window.$f_9 = f_9;
window.$f_10 = f_10;
window.$f_11 = f_11;

/* FORKET CLIENT */
// @ts-ignore
(()=>{(function(){let $=new Map,f=window.$F_renderers={},y={class:"className",for:"htmlFor",readonly:"readOnly",tabindex:"tabIndex",maxlength:"maxLength",colspan:"colSpan",rowspan:"rowSpan"},L=new Set(["allowfullscreen","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","hidden","inert","ismap","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected"]);function _(){let i=document,c=typeof window.$FRSC_<"u"?window.$FRSC_:[];$F_logc(`\u{10090} [client] \u{1F3DD}\uFE0F(${c.length}) v0.9.0`),typeof window.$FRSC>"u"&&(window.$FRSC=function(t){let n=t[0],e=t[1],o=l(t[2]),r=u(n);return d(n,e,o,r)}),c.length>0&&(c=window.$FRSC_=c.filter(t=>!window.$FRSC(t)));function d(t,n,e,o){return f[t]=function(r){let s=window["$"+t];if(!s)return console.warn(`\u{10090} Component <${n}> not found in the global scope yet. (${t})`),!1;let a={start:i.querySelector(`template[type="forket/start/${t}"]`),end:i.querySelector(`template[type="forket/end/${t}"]`)};if(!a.start||!a.end)return console.warn(`\u{10090} Boundary not found for <${n}>. Re-trying rendering in 1 sec.`),setTimeout(()=>f[t](r),1e3),!1;let w=i.createElement("div");return p(a.start,a.end,w),w.style.display="contents",a.end.parentNode.insertBefore(w,a.end),a.end.parentNode.removeChild(a.start),a.end.parentNode.removeChild(a.end),f[t]=function(F){return F&&(e={...e,...F}),$F_logc(`\u{10090} [client] Render <${n}> (${t})`,{props:e,children:o}),b(w,React.createElement(s,e,o)),!0},f[t](r)},f[t]()}function l(t){try{t=JSON.parse(t,function(n,e){if(n!=="children"){if(typeof e=="string"&&e.match(/^\$FSA_/)){let o=e.split("_").pop();return window.FSA_call(e,o)}else if(typeof e=="string"&&e.match(/^\$FLP_/))return new Promise((o,r)=>{let s=e.replace(/^\$FLP_/,"");if(typeof window.$FLP_>"u"&&(window.$FLP_={}),typeof window.$FLP_[s]>"u")window.$FLP_[s]={status:"unknown",resolve:o,reject:r};else if(window.$FLP_[s].status==="resolved"){o(window.$FLP_[s].value);return}else if(window.$FLP_[s].status==="rejected"){r(new Error(window.$FLP_[s].value));return}else window.$FLP_[s].resolve=o,window.$FLP_[s].reject=r,h(s)});return e}})}catch(n){console.warn("\u{10090} Error parsing props content:",n),t={}}return t}function u(t){let n=i.querySelector(`template[type="forket/children"]#${t}`);if(!n)return null;let e=n.innerHTML;return n?.parentNode?.removeChild(n),N(e)}function p(t,n,e){let o=t.nextSibling;for(;o&&o!==n;){let r=o.nextSibling;e.appendChild(o),o=r}}function N(t){let n=document.createElement("template");n.innerHTML=t;let e=[];return n.content.childNodes.forEach((o,r)=>{let s=m(o,`root.${r}`);Array.isArray(s)?e.push(...s):s!==null&&s!==""&&e.push(s)}),e}function S(t){return t.replace(/-([a-z])/g,(n,e)=>e.toUpperCase())}function g(t){let n={};return t.split(";").forEach(e=>{let[o,r]=e.split(":");if(!o||!r)return;let s=S(o.trim()),a=r.trim();!Number.isNaN(Number(a))&&a!==""&&(a=Number(a)),n[s]=a}),n}function E(t){let n={};for(let e of t.attributes){let o=e.name.toLowerCase(),r=y[o]||o;if(!/^on[a-z]+$/.test(r)){if(r==="style"){n.style=g(e.value||"");continue}if(L.has(o)){n[r]=e.value===""||e.value.toLowerCase()===o||e.value.toLowerCase()==="true";continue}n[r]=e.value}}return n}function m(t,n){switch(t.nodeType){case Node.ELEMENT_NODE:{let e=t.tagName.toLowerCase(),o={...E(t),key:n},r=[];return t.childNodes.forEach((s,a)=>{let w=m(s,`${n}.${a}`);w!==null&&w!==""&&r.push(w)}),r.length?React.createElement(e,o,...r):React.createElement(e,o)}case Node.TEXT_NODE:{let e=t.nodeValue;return e&&!/^\s+$/.test(e)?e:null}case Node.DOCUMENT_FRAGMENT_NODE:{let e=[];return t.childNodes.forEach((o,r)=>{let s=m(o,`${n}.${r}`);s!==null&&s!==""&&e.push(s)}),e.length?e:null}default:return null}}function b(t,n){let e=$.get(t);e?e.render(n):(e=ReactDomClient.hydrateRoot(t,n),$.set(t,e))}}function h(i){if(typeof i>"u"){console.warn("\u{10090} FLP_process called without id.");return}if(typeof window.$FLP_<"u"&&window.$FLP_[i]){let c=window.$FLP_[i].value,d=window.$FLP_[i].status,l=window.$FLP_[i].resolve,u=window.$FLP_[i].reject,p=window.$FLP_[i].boundaryID;if(d==="resolved")$F_logc(`\u{10090} [client] Promise resolved (${i})`,c),l?(l(c),delete window.$FLP_[i]):$F_logc(`\u{10090} [client] Promise with id ${i} is resolved but can't be consumed because the client boundary that needs it is not render yet.`);else if(d==="rejected")$F_logc(`\u{10090} [client] Promise rejected (${i})`,c),u?(delete window.$FLP_[i],u(new Error(c))):$F_logc(`\u{10090} [client] Promise with id ${i} is rejected but can't be consumed because the client boundary that needs it is not render yet.`);else{console.warn(`\u{10090} [client] Promise with id ${i} is in unknown state: ${d}.`);return}f[p]&&f[p]()}else console.warn(`\u{10090} [client] Promise with id ${i} not found in the global scope. The promise is resolved/rejected but the component boundary that needs it is not rendered yet or the promise is already consumed somehow.`)}function P(i,c){return async function(...d){let l;typeof FormData<"u"&&d[0]instanceof FormData?(l=d[0],l.append("__kind","formdata")):(l=new FormData,l.append("__args",JSON.stringify(d)),l.append("__kind","json")),l.append("__actionId",i);let u=await fetch($F_sae+"/"+c,{method:"POST",body:l});if(!u.ok)throw new Error(`Server action ${i} failed with status ${u.status}`);return(await u.json()).result}}window.FRSC_init=_,window.FSA_call=P,window.FLP_process=h,_()})();})();
